/*
 * Copyright (c) 2024-2025.  little3201.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package top.leafage.hypervisor.exploiter.service.impl;

import freemarker.template.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.cglib.beans.BeanCopier;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.r2dbc.core.R2dbcEntityTemplate;
import org.springframework.data.relational.core.query.Criteria;
import org.springframework.data.relational.core.query.Query;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.Assert;
import org.springframework.util.CollectionUtils;
import org.springframework.util.StringUtils;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;
import top.leafage.hypervisor.constants.FieldConstant;
import top.leafage.hypervisor.constants.FieldTypeEnum;
import top.leafage.hypervisor.exploiter.domain.Field;
import top.leafage.hypervisor.exploiter.domain.Schema;
import top.leafage.hypervisor.exploiter.domain.dto.SchemaDTO;
import top.leafage.hypervisor.exploiter.domain.vo.ColumnVO;
import top.leafage.hypervisor.exploiter.domain.vo.FieldVO;
import top.leafage.hypervisor.exploiter.domain.vo.SampleVO;
import top.leafage.hypervisor.exploiter.domain.vo.SchemaVO;
import top.leafage.hypervisor.exploiter.repository.*;
import top.leafage.hypervisor.exploiter.service.SchemaService;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

/**
 * schema service
 *
 * @author wq li
 */
@Service
public class SchemaServiceImpl implements SchemaService {

    private static final Logger logger = LoggerFactory.getLogger(SchemaServiceImpl.class);
    private static final BeanCopier copier = BeanCopier.create(SchemaDTO.class, Schema.class, false);
    private final Configuration cfg = new Configuration(Configuration.VERSION_2_3_33);
    private final ConnectionRepository connectionRepository;
    private final SchemaRepository schemaRepository;
    private final FieldRepository fieldRepository;
    private final SampleRepository sampleRepository;
    private final R2dbcEntityTemplate r2dbcEntityTemplate;
    private final DbRepository dbRepository;

    public SchemaServiceImpl(ConnectionRepository connectionRepository, SchemaRepository schemaRepository, FieldRepository fieldRepository,
                             SampleRepository sampleRepository, R2dbcEntityTemplate r2dbcEntityTemplate, DbRepository dbRepository) {
        this.connectionRepository = connectionRepository;
        this.schemaRepository = schemaRepository;
        this.fieldRepository = fieldRepository;
        this.sampleRepository = sampleRepository;
        this.r2dbcEntityTemplate = r2dbcEntityTemplate;
        this.dbRepository = dbRepository;

        cfg.setDefaultEncoding("UTF-8");
        cfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);
        // 注册自定义函数
        cfg.setSharedVariable("camel", new CamelTemplateMethodEx());
        cfg.setSharedVariable("singular", new SingularTemplateMethodEx());
        cfg.setSharedVariable("camel_singular", new CamelAndSingularTemplateMethodEx());
    }

    @Override
    public Mono<Page<SchemaVO>> retrieve(int page, int size, String sortBy, boolean descending, String filters) {
        Pageable pageable = PageRequest.of(page, size);
        Criteria criteria = buildCriteria(filters, Schema.class);

        return r2dbcEntityTemplate.select(Schema.class)
                .matching(Query.query(criteria).with(pageable))
                .all()
                .map(SchemaVO::from)
                .collectList()
                .zipWith(r2dbcEntityTemplate.count(Query.query(criteria), Schema.class))
                .map(tuple -> new PageImpl<>(tuple.getT1(), pageable, tuple.getT2()));
    }

    @Override
    public Flux<SchemaVO> retrieve(List<Long> ids) {
        if (CollectionUtils.isEmpty(ids)) {
            return schemaRepository.findAll()
                    .map(SchemaVO::from);
        }
        return schemaRepository.findAllById(ids)
                .map(SchemaVO::from);
    }

    @Override
    public Mono<SchemaVO> fetch(Long id) {
        Assert.notNull(id, ID_MUST_NOT_BE_NULL);

        return schemaRepository.findById(id)
                .map(SchemaVO::from);
    }

    @Transactional
    @Override
    public Mono<SchemaVO> create(SchemaDTO dto) {
        return schemaRepository.existsByName(dto.getName())
                .flatMap(exists -> {
                    if (exists) {
                        return Mono.error(new IllegalArgumentException("name already exists: " + dto.getName()));
                    }
                    return schemaRepository.save(SchemaDTO.toEntity(dto))
                            .flatMap(entity -> connectionRepository.findById(dto.getConnectionId())
                                    .switchIfEmpty(Mono.error(new NoSuchElementException("Connection not found: " + dto.getConnectionId())))
                                    .flatMapMany(connection -> dbRepository.findAllColumnsByTableName(
                                            connection.getHost(), connection.getPort(), connection.getName(),
                                            connection.getUsername(), connection.getPassword(), dto.getName()
                                    ))
                                    .filter(columnVO -> !FieldConstant.metadata.contains(columnVO.columnName()))
                                    .map(columnVO -> constructField(columnVO, entity.getId()))
                                    .collectList()
                                    .flatMapMany(fieldRepository::saveAll)
                                    .then(Mono.just(SchemaVO.from(entity)))
                            );
                });
    }

    @Transactional
    @Override
    public Flux<SchemaVO> createAll(Iterable<SchemaDTO> iterable) {
        List<Schema> schemas = StreamSupport.stream(iterable.spliterator(), false)
                .map(SchemaDTO::toEntity).toList();
        return schemaRepository.saveAll(schemas)
                .map(SchemaVO::from);
    }

    @Transactional
    @Override
    public Mono<SchemaVO> modify(Long id, SchemaDTO dto) {
        Assert.notNull(id, ID_MUST_NOT_BE_NULL);

        return schemaRepository.findById(id)
                .switchIfEmpty(Mono.error(NoSuchElementException::new))
                .flatMap(existing -> {
                    copier.copy(dto, existing, null);
                    return schemaRepository.save(existing);
                })
                .map(SchemaVO::from);
    }

    @Transactional
    @Override
    public Mono<Boolean> enable(Long id) {
        Assert.notNull(id, ID_MUST_NOT_BE_NULL);

        return schemaRepository.existsById(id)
                .flatMap(exists -> {
                    if (!exists) {
                        return Mono.error(new NoSuchElementException("schema not found: " + id));
                    }
                    return schemaRepository.updateEnabledById(id)
                            .map(count -> count > 0);
                });
    }

    @Transactional
    @Override
    public Mono<Void> remove(Long id) {
        Assert.notNull(id, ID_MUST_NOT_BE_NULL);

        return schemaRepository.existsById(id)
                .flatMap(exists -> {
                    if (!exists) {
                        return Mono.error(new NoSuchElementException("schema not found: " + id));
                    }
                    return fieldRepository.findAllBySchemaId(id)
                            .map(Field::getId)
                            .collectList()
                            .flatMap(fieldRepository::deleteAllById)
                            .then(schemaRepository.deleteById(id));
                });
    }

    @Transactional
    @Override
    public Flux<FieldVO> sync(Long id) {
        Assert.notNull(id, ID_MUST_NOT_BE_NULL);

        return schemaRepository.findById(id)
                .switchIfEmpty(Mono.error(NoSuchElementException::new))
                .flatMapMany(schema -> fieldRepository.findAllBySchemaId(id)
                        .collectMap(Field::getName)
                        .flatMapMany(existingFields -> connectionRepository.findById(schema.getConnectionId())
                                .flatMapMany(connection -> dbRepository.findAllColumnsByTableName(
                                                connection.getHost(),
                                                connection.getPort(),
                                                connection.getName(),
                                                connection.getUsername(),
                                                connection.getPassword(),
                                                schema.getName()
                                        )
                                        .filter(columnVO -> !FieldConstant.metadata.contains(columnVO.columnName()))
                                        .map(columnVO -> {
                                            Field field = existingFields.get(columnVO.columnName());
                                            if (field == null) {
                                                field = constructField(columnVO, id);
                                            }
                                            return field;
                                        })))
                        .collectList()
                        .flatMapMany(fieldRepository::saveAll)
                        .map(FieldVO::from));
    }

    @Transactional
    @Override
    public Mono<byte[]> execute(Long id) {
        Assert.notNull(id, ID_MUST_NOT_BE_NULL);

        return schemaRepository.findById(id)
                .switchIfEmpty(Mono.error(NoSuchElementException::new))
                .flatMap(schema -> {
                    Path tempDir = Paths.get(System.getProperty("user.dir"), "temp", schema.getName());

                    Path zipFile = tempDir.resolve(schema.getName() + ".zip");
                    return Mono.using(() -> tempDir, dir -> Mono.fromCallable(() -> {
                                generateTemplateFiles(schema, dir);
                                createZipFile(dir, zipFile);
                                return Files.readAllBytes(zipFile);
                            })
                            .subscribeOn(Schedulers.boundedElastic()), this::clearHistory, true);
                });
    }

    @Override
    public Flux<SampleVO.Rendered> preview(Long id) {
        return schemaRepository.findById(id)
                .switchIfEmpty(Mono.error(() -> new NoSuchElementException("Schema not found: " + id)))
                .flatMapMany(schema -> Flux.fromIterable(schema.getSamples())
                        .flatMap(sampleId -> sampleRepository.findById(sampleId)
                                .switchIfEmpty(Mono.error(() -> new IllegalStateException("Sample not found: " + sampleId)))
                        )
                        .flatMap(entity -> createDataModel(schema)
                                .map(dataModel -> {
                                    String formattedName = formatName(schema.getName(), entity.getName(), entity.getModule());
                                    String renderedBody = renderTemplate(formattedName, entity.getBody(), dataModel);
                                    return SampleVO.from(entity, formattedName, renderedBody);
                                })
                        )
                        .collectMultimap(SampleVO::type)
                        .flatMapMany(map -> Flux.fromIterable(map.entrySet()))
                        .map(entry -> SampleVO.toRendered(entry.getKey(), entry.getValue()))
                );
    }

    private void generateTemplateFiles(Schema schema, Path tempDir) {
        Mono.fromCallable(() -> Files.createDirectories(tempDir))
                .subscribeOn(Schedulers.boundedElastic())
                .thenMany(Flux.fromIterable(schema.getSamples()))
                .flatMap(sampleId -> sampleRepository.findById(sampleId)
                        .switchIfEmpty(Mono.error(() -> new IllegalStateException("Sample not found: " + sampleId)))
                )
                .concatMap(entity -> {
                    String fileName = formatName(schema.getName(), entity.getName(), entity.getModule());
                    Path targetFile = tempDir.resolve(fileName);

                    return createDataModel(schema).flatMap(dataModel ->
                            Mono.fromCallable(() -> {
                                        Path parent = targetFile.getParent();
                                        if (parent != null) Files.createDirectories(parent);

                                        writeTemplate(fileName, entity.getBody(), dataModel, targetFile.toString());
                                        logger.debug("Generated: {}", targetFile);
                                        return null;
                                    })
                                    .subscribeOn(Schedulers.boundedElastic())
                                    .onErrorMap(e -> new RuntimeException("Failed to generate: " + fileName, e))
                    );
                })
                .then();
    }

    private void createZipFile(Path sourceDir, Path zipFile) {
        try (FileOutputStream fos = new FileOutputStream(zipFile.toFile());
             ZipOutputStream zos = new ZipOutputStream(fos);
             Stream<Path> walk = Files.walk(sourceDir)) {

            walk.filter(Files::isRegularFile)
                    .forEach(filePath -> {
                        try {
                            zipFile(filePath, sourceDir, zos);
                        } catch (IOException e) {
                            throw new RuntimeException("Failed to zip file: " + filePath, e);
                        }
                    });

            logger.info("Created zip file: {}", zipFile);
        } catch (IOException e) {
            throw new RuntimeException("Failed to create zip file", e);
        }
    }

    private void zipFile(Path fileToZip, Path sourceDir, ZipOutputStream zos) throws IOException {
        Path relativePath = sourceDir.relativize(fileToZip);
        ZipEntry zipEntry = new ZipEntry(relativePath.toString());
        zos.putNextEntry(zipEntry);

        Files.copy(fileToZip, zos);
        zos.closeEntry();
    }

    // 创建数据模型
    private Mono<Map<String, Object>> createDataModel(Schema schema) {
        Assert.notNull(schema.getId(), String.format(_MUST_NOT_BE_NULL, "schema id"));
        return fieldRepository.findAllBySchemaId(schema.getId())
                .collectList()
                .map(fields -> Map.<String, Object>ofEntries(
                        Map.entry("name", schema.getName()),
                        Map.entry("packagePath", schema.getPackageName()),
                        Map.entry("fields", fields)
                ));
    }

    // 构造
    private Field constructField(ColumnVO vo, Long schemaId) {
        Field field = new Field();
        field.setSchemaId(schemaId);
        field.setName(vo.columnName());
        field.setDataType(vo.dataType());
        field.setLength(vo.maximumLength());
        FieldTypeEnum fieldTypeEnum = FieldTypeEnum.getByDbType(vo.dataType());
        if (fieldTypeEnum != null) {
            field.setFieldType(fieldTypeEnum.getJavaType());
            field.setFormType(fieldTypeEnum.getFormType());
            field.setTsType(fieldTypeEnum.getTsType());
        }
        field.setNullable(vo.nullable());
        field.setUnique(vo.unique());
        return field;
    }

    // 清除历史
    private void clearHistory(Path path) {
        if (!Files.exists(path)) {
            return;
        }
        try (Stream<Path> pathStream = Files.walk(path)) {
            pathStream.sorted(Comparator.reverseOrder()).forEach(file -> {
                try {
                    Files.delete(file);
                } catch (IOException e) {
                    logger.error("File: {} delete failure.", file, e);
                }
            });
        } catch (IOException e) {
            logger.error("File: {} delete failure.", path, e);
        }
    }

    // 渲染模板并将结果写入文件
    private void writeTemplate(String name, String content, Map<String, Object> dataModel, String reference) {
        Path outputPath = Paths.get(reference);

        try {
            // 确保父目录存在
            Files.createDirectories(outputPath.getParent());

            // 使用NIO API进行文件写入
            try (BufferedWriter writer = Files.newBufferedWriter(outputPath, StandardCharsets.UTF_8)) {
                Template freemarkerTemplate = new Template(
                        name,
                        new StringReader(content),
                        cfg);

                freemarkerTemplate.process(dataModel, writer);
            }
        } catch (IOException e) {
            logger.error("Failed to create directories or write file: {}", reference, e);
        } catch (TemplateException e) {
            logger.error("Template rendering failed for sample: {}", name, e);
        }
    }

    private String formatName(String schemaName, String sampleName, String suffix) {
        if (!sampleName.startsWith("%s")) {
            return sampleName + suffix;
        }

        String formattedSchemaName = ".ts".equals(suffix)
                ? schemaName.replace("_", "-")
                : camelAndSingular(schemaName);

        return String.format(sampleName + suffix, formattedSchemaName);
    }

    // 渲染模板并将结果写入文件
    private String renderTemplate(String name, String content, Map<String, Object> dataModel) {
        // 将模板内容加载到 FreeMarker 并渲染
        try (StringWriter stringWriter = new StringWriter()) {
            Template freemarker = new Template(name, new StringReader(content), cfg);
            freemarker.process(dataModel, stringWriter);
            return stringWriter.toString();
        } catch (IOException | TemplateException e) {
            logger.error("模板渲染异常：{}", e.getMessage(), e);
            return "";
        }
    }

    private String camelAndSingular(String name) {
        if (!StringUtils.hasText(name)) {
            return name;
        }

        String[] words = name.split("_");
        // 最后一个单词复数转单数
        words[words.length - 1] = toSingular(words[words.length - 1]);
        StringBuilder stringBuilder = new StringBuilder();
        for (String word : words) {
            stringBuilder.append(word.substring(0, 1).toUpperCase()).append(word.substring(1));
        }
        return stringBuilder.toString();
    }

    private String toSingular(String word) {
        if (!StringUtils.hasText(word)) {
            return word;
        }

        if (word.matches(".*[^aeiou]ies$")) {
            return word.replaceAll("ies$", "y");
        } else if (word.matches(".*[lf]ves$")) {
            return word.replaceAll("ves$", "f");
        } else if (word.matches(".*(ch|sh|x|s|z)es$")) {
            return word.replaceAll("es$", "");
        } else if (word.matches(".*[a-z]s$") && !word.endsWith("ss")) {
            return word.replaceAll("s$", "");
        } else {
            return word;
        }
    }

    /**
     * 转驼峰
     */
    static class CamelTemplateMethodEx implements TemplateMethodModelEx {

        @Override
        public Object exec(List arguments) {
            String name = arguments.getFirst().toString();
            if (!StringUtils.hasText(name)) {
                return name;
            }

            String[] words = name.split("_");
            // 最后一个单词复数转单数
            StringBuilder stringBuilder = new StringBuilder();
            for (String word : words) {
                stringBuilder.append(word.substring(0, 1).toUpperCase()).append(word.substring(1));
            }
            return stringBuilder.toString();
        }
    }

    /**
     * 转单数
     */
    class SingularTemplateMethodEx implements TemplateMethodModelEx {

        @Override
        public Object exec(List arguments) {
            return toSingular(arguments.getFirst().toString());
        }
    }

    /**
     * 转驼峰，并将最后一个转单数
     */
    class CamelAndSingularTemplateMethodEx implements TemplateMethodModelEx {

        @Override
        public Object exec(List arguments) {
            return camelAndSingular(arguments.getFirst().toString());
        }
    }

}
