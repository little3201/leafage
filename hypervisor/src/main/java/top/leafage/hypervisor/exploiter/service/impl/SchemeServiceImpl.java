/*
 * Copyright (c) 2024-2025.  little3201.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package top.leafage.hypervisor.exploiter.service.impl;

import freemarker.template.*;
import jakarta.persistence.EntityNotFoundException;
import org.jspecify.annotations.NonNull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.cglib.beans.BeanCopier;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.Assert;
import org.springframework.util.CollectionUtils;
import org.springframework.util.StringUtils;
import top.leafage.hypervisor.constants.FieldConstant;
import top.leafage.hypervisor.constants.FieldTypeEnum;
import top.leafage.hypervisor.exploiter.domain.Connection;
import top.leafage.hypervisor.exploiter.domain.Field;
import top.leafage.hypervisor.exploiter.domain.Scheme;
import top.leafage.hypervisor.exploiter.domain.dto.FieldDTO;
import top.leafage.hypervisor.exploiter.domain.dto.SchemeDTO;
import top.leafage.hypervisor.exploiter.domain.vo.ColumnVO;
import top.leafage.hypervisor.exploiter.domain.vo.FieldVO;
import top.leafage.hypervisor.exploiter.domain.vo.SampleVO;
import top.leafage.hypervisor.exploiter.domain.vo.SchemeVO;
import top.leafage.hypervisor.exploiter.repository.*;
import top.leafage.hypervisor.exploiter.service.SchemeService;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

@Service
public class SchemeServiceImpl implements SchemeService {

    private static final Logger logger = LoggerFactory.getLogger(SchemeServiceImpl.class);

    public static final List<String> metadata = List.of("id", "enabled", "created_by", "created_date", "last_modified_by", "last_modified_date");

    private static final String TEMP_DIR = "temp";
    private static final BeanCopier copier = BeanCopier.create(SchemeDTO.class, Scheme.class, false);
    private static final BeanCopier filedCopier = BeanCopier.create(FieldDTO.class, Field.class, false);
    private final Configuration cfg = new Configuration(Configuration.VERSION_2_3_33);

    private final ConnectionRepository connectionRepository;
    private final SchemeRepository schemeRepository;
    private final FieldRepository fieldRepository;
    private final SampleRepository sampleRepository;
    private final DbRepository dbRepository;


    public SchemeServiceImpl(ConnectionRepository connectionRepository, SchemeRepository schemeRepository, FieldRepository fieldRepository, SampleRepository sampleRepository, DbRepository dbRepository) {
        this.connectionRepository = connectionRepository;
        this.schemeRepository = schemeRepository;
        this.fieldRepository = fieldRepository;
        this.sampleRepository = sampleRepository;
        this.dbRepository = dbRepository;

        cfg.setDefaultEncoding("UTF-8");
        cfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);
        // 注册自定义函数
        cfg.setSharedVariable("camel", new CamelTemplateMethodEx());
        cfg.setSharedVariable("singular", new SingularTemplateMethodEx());
        cfg.setSharedVariable("camel_singular", new CamelAndSingularTemplateMethodEx());
    }

    @Override
    public Page<@NonNull SchemeVO> retrieve(int page, int size, String sortBy, boolean descending, String filters) {
        Pageable pageable = PageRequest.of(page, size);

        Specification<@NonNull Scheme> spec = (root, query, cb) -> buildPredicate(filters, cb, root).orElse(null);

        return schemeRepository.findAll(spec, pageable).map(SchemeVO::from);
    }

    @Override
    public List<SchemeVO> retrieve(List<Long> ids) {
        if (CollectionUtils.isEmpty(ids)) {
            return schemeRepository.findAll().stream().map(SchemeVO::from).toList();
        } else {
            return schemeRepository.findAllById(ids).stream().map(SchemeVO::from).toList();
        }
    }

    @Override
    public SchemeVO fetch(Long id) {
        Assert.notNull(id, ID_MUST_NOT_BE_NULL);

        return schemeRepository.findById(id).map(SchemeVO::from)
                .orElseThrow(() -> new EntityNotFoundException("scheme not found: " + id));
    }

    @Transactional
    @Override
    public SchemeVO create(SchemeDTO dto) {
        Scheme entity = schemeRepository.save(SchemeDTO.toEntity(dto));

        // 获取连接信息，避免重复查询
        Connection connection = connectionRepository.findById(dto.getConnectionId())
                .orElseThrow(() -> new EntityNotFoundException("Connection not found: " + dto.getConnectionId()));

        // 确定需要处理的表集合
        Set<String> tables = Scheme.SchemaScope.ALL.equals(Scheme.SchemaScope.of(dto.getScope()))
                ? new HashSet<>(dbRepository.findAllTables(
                connection.getHost(), connection.getPort(),
                connection.getDatabase(), connection.getUsername(),
                connection.getPassword(), connection.getParams()
        )) : dto.getTables();

        // 处理字段
        if (!CollectionUtils.isEmpty(tables)) {
            List<Field> fields = tables.stream()
                    .flatMap(tableName -> dbRepository.findAllColumnsByTableName(
                                    connection.getHost(), connection.getPort(),
                                    connection.getDatabase(), connection.getUsername(),
                                    connection.getPassword(), connection.getParams(), tableName)
                            .stream()
                            .filter(columnVO -> !metadata.contains(columnVO.columnName()))
                            .map(columnVO -> {
                                Field field = new Field();
                                field.setSchemaId(entity.getId());
                                constructField(field, columnVO);
                                field.setTableName(tableName);  // 设置字段的表名
                                return field;
                            })
                    ).toList();

            fieldRepository.saveAll(fields);
        }

        return SchemeVO.from(entity);
    }

    @Transactional
    @Override
    public List<SchemeVO> createAll(Iterable<SchemeDTO> iterable) {
        List<Scheme> schemes = StreamSupport.stream(iterable.spliterator(), false)
                .map(SchemeDTO::toEntity).toList();

        return schemeRepository.saveAll(schemes).stream().map(SchemeVO::from).toList();
    }

    @Transactional
    @Override
    public SchemeVO modify(Long id, SchemeDTO dto) {
        Assert.notNull(id, ID_MUST_NOT_BE_NULL);

        Scheme existing = schemeRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("scheme not found: " + id));

        copier.copy(dto, existing, null);
        Scheme entity = schemeRepository.save(existing);
        return SchemeVO.from(entity);
    }

    @Override
    public List<FieldVO> fields(Long id, String tableName) {
        Assert.notNull(id, ID_MUST_NOT_BE_NULL);
        Assert.notNull(tableName, String.format(_MUST_NOT_BE_EMPTY, "tableName"));

        return fieldRepository.findAllBySchemeIdAndTableName(id, tableName)
                .stream().map(FieldVO::from)
                .toList();
    }

    @Transactional
    @Override
    public void sync(Long id) {
        schemeRepository.findById(id).ifPresent(scheme -> {
            // 获取现有字段映射
            Map<String, Field> existingFields = fieldRepository.findAllBySchemeId(id)
                    .stream()
                    .collect(Collectors.toMap(
                            f -> f.getTableName() + ":" + f.getName(),
                            f -> f,
                            (existing, replacement) -> existing
                    ));

            // 获取数据库连接信息
            connectionRepository.findById(scheme.getConnectionId()).ifPresent(connection -> {
                // 获取所有字段数据并进行转换
                List<Field> fields = scheme.getTables().stream()
                        .flatMap(tableName -> dbRepository.findAllColumnsByTableName(
                                        connection.getHost(), connection.getPort(),
                                        connection.getDatabase(), connection.getUsername(),
                                        connection.getPassword(), connection.getParams(), tableName)
                                .stream()
                                .filter(columnVO -> !metadata.contains(columnVO.columnName()))  // 过滤不需要的字段
                                .map(columnVO -> {
                                    // 使用组合Key匹配
                                    String key = tableName + ":" + columnVO.columnName();
                                    Field field = existingFields.getOrDefault(key, new Field());
                                    if (field.isNew()) {
                                        field.setSchemaId(id);
                                        field.setTableName(tableName);  // 设置表名
                                    }
                                    return constructField(field, columnVO);  // 转换成Field对象
                                })
                        ).collect(Collectors.toList());

                // 如果有新的字段数据，保存到数据库
                if (!fields.isEmpty()) {
                    fieldRepository.saveAll(fields);
                }
            });
        });
    }

    @Transactional
    @Override
    public List<FieldVO> config(Long id, String tableName, List<FieldDTO> dtoList) {
        Map<String, Field> fieldMap = fieldRepository.findAllBySchemeIdAndTableName(id, tableName)
                .stream().collect(Collectors.toMap(Field::getName, field -> field));

        List<Field> entities = new ArrayList<>(dtoList.size());
        dtoList.forEach(dto -> {
            if (fieldMap.containsKey(dto.getName())) {
                Field existing = fieldMap.get(dto.getName());
                filedCopier.copy(dto, existing, null);
                entities.add(existing);
            }
        });
        return fieldRepository.saveAll(entities)
                .stream().map(FieldVO::from)
                .toList();
    }

    @Override
    public byte[] execute(Long id) {
        Assert.notNull(id, ID_MUST_NOT_BE_NULL);

        Scheme scheme = schemeRepository.findById(id).orElseThrow(() -> new EntityNotFoundException("scheme not found: " + id));

        Path tempDir = Paths.get(System.getProperty("user.dir"), TEMP_DIR, scheme.getModule());
        try {
            generateTemplateFiles(scheme, tempDir);

            Path zipFile = tempDir.resolve(scheme.getModule() + ".zip");
            createZipFile(tempDir, zipFile);

            return Files.readAllBytes(zipFile);
        } catch (IOException e) {
            logger.error("Failed to generate zip file for scheme: {}", scheme.getModule(), e);
            throw new RuntimeException("Failed to generate zip file", e);
        } finally {
            clearHistory(tempDir);
        }
    }

    @Override
    public List<SampleVO.Rendered> preview(Long id) {
        Assert.notNull(id, ID_MUST_NOT_BE_NULL);

//        Scheme scheme = schemeRepository.findById(id).orElseThrow();

        return Collections.emptyList();
    }

    @Transactional
    @Override
    public boolean enable(Long id) {
        Assert.notNull(id, ID_MUST_NOT_BE_NULL);

        if (!schemeRepository.existsById(id)) {
            throw new EntityNotFoundException("scheme not found: " + id);
        }
        return schemeRepository.updateEnabledById(id) > 0;
    }

    @Transactional
    @Override
    public void remove(Long id) {
        Assert.notNull(id, ID_MUST_NOT_BE_NULL);

        if (!schemeRepository.existsById(id)) {
            throw new EntityNotFoundException("scheme not found: " + id);
        }
        List<Long> ids = fieldRepository.findAllBySchemeId(id).stream().map(Field::getId).toList();
        fieldRepository.deleteAllById(ids);

        schemeRepository.deleteById(id);
    }

    // 构造
    private Field constructField(Field field, ColumnVO columnVO) {
        field.setName(columnVO.columnName());
        field.setDataType(columnVO.dataType());
        field.setLength(columnVO.maximumLength());
        FieldTypeEnum fieldTypeEnum = FieldTypeEnum.fromDbType(columnVO.dataType());
        if (fieldTypeEnum != null) {
            field.setFieldType(fieldTypeEnum.getJavaType());
            field.setFormType(fieldTypeEnum.getFormType());
            field.setTsType(fieldTypeEnum.getTsType());
        }
        field.setNullable(columnVO.nullable());
        field.setUnique(columnVO.unique());
        return field;
    }

    private void generateTemplateFiles(Scheme scheme, Path tempDir) {
        List<Module> modules = new ArrayList<>();
//        modules.stream().flatMap(templateId -> sampleRepository.findById(templateId).stream()).forEach(template -> {
//            try {
//                String formattedName = formatName(scheme.getModule(), template.getName(), template.getFilePath());
//                Path tempFile = tempDir.resolve(formattedName);
//
//                // 确保父目录存在
//                Files.createDirectories(tempFile.getParent());
//
//                Map<String, Object> dataModel = createDataModel(scheme);
//                writeTemplate(formattedName, template.getBody(), dataModel, tempFile.toString());
//
//                logger.debug("Generated template file: {}", formattedName);
//            } catch (Exception e) {
//                logger.error("Failed to generate template: {}", template.getName(), e);
//                throw new RuntimeException("Failed to generate template: " + template.getName(), e);
//            }
//        });
    }

    private void createZipFile(Path sourceDir, Path zipFile) {
        try (FileOutputStream fos = new FileOutputStream(zipFile.toFile()); ZipOutputStream zos = new ZipOutputStream(fos); Stream<Path> walk = Files.walk(sourceDir)) {

            walk.filter(Files::isRegularFile).forEach(filePath -> {
                try {
                    zipFile(filePath, sourceDir, zos);
                } catch (IOException e) {
                    throw new RuntimeException("Failed to zip file: " + filePath, e);
                }
            });

            logger.info("Created zip file: {}", zipFile);
        } catch (IOException e) {
            throw new RuntimeException("Failed to create zip file", e);
        }
    }

    private void zipFile(Path fileToZip, Path sourceDir, ZipOutputStream zos) throws IOException {
        Path relativePath = sourceDir.relativize(fileToZip);
        ZipEntry zipEntry = new ZipEntry(relativePath.toString());
        zos.putNextEntry(zipEntry);

        Files.copy(fileToZip, zos);
        zos.closeEntry();
    }

    // 创建数据模型
    private Map<String, Object> createDataModel(Scheme scheme) {
        Map<String, Object> dataModel = new HashMap<>();
        dataModel.put("name", scheme.getModule());
        dataModel.put("packagePath", scheme.getPackageName());
        return dataModel;
    }

    // 清除历史
    private void clearHistory(Path path) {
        if (!Files.exists(path)) {
            return;
        }
        try (Stream<Path> pathStream = Files.walk(path)) {
            pathStream.sorted(Comparator.reverseOrder()).forEach(file -> {
                try {
                    Files.delete(file);
                } catch (IOException e) {
                    logger.error("File: {} delete failure.", file, e);
                }
            });
        } catch (IOException e) {
            logger.error("File: {} delete failure.", path, e);
        }
    }

    // 渲染模板并将结果写入文件
    private void writeTemplate(String name, String content, Map<String, Object> dataModel, String reference) {
        Path outputPath = Paths.get(reference);

        try {
            // 确保父目录存在
            Files.createDirectories(outputPath.getParent());

            // 使用NIO API进行文件写入
            try (BufferedWriter writer = Files.newBufferedWriter(outputPath, StandardCharsets.UTF_8)) {
                Template freemarker = new Template(name, new StringReader(content), cfg);

                freemarker.process(dataModel, writer);
            }
        } catch (IOException e) {
            logger.error("Failed to create directories or write file: {}", reference, e);
        } catch (TemplateException e) {
            logger.error("Template rendering failed for template: {}", name, e);
        }
    }

    private String formatName(String schemaName, String templateName, String suffix) {
        if (!templateName.startsWith("%s")) {
            return templateName;
        }

        String formattedSchemaName = ".ts".equals(suffix) ? schemaName.replace("_", "-") : camelAndSingular(schemaName);

        return String.format(templateName, formattedSchemaName);
    }

    // 渲染模板并将结果写入文件
    private String renderTemplate(String name, String content, Map<String, Object> dataModel) {
        // 将模板内容加载到 FreeMarker 并渲染
        try (StringWriter stringWriter = new StringWriter()) {
            Template freemarker = new Template(name, new StringReader(content), cfg);
            freemarker.process(dataModel, stringWriter);
            return stringWriter.toString();
        } catch (IOException | TemplateException e) {
            logger.error("模板渲染异常：{}", e.getMessage(), e);
            return null;
        }
    }

    private String camelAndSingular(String name) {
        if (!StringUtils.hasText(name)) {
            return name;
        }

        String[] words = name.split("_");
        // 最后一个单词复数转单数
        words[words.length - 1] = toSingular(words[words.length - 1]);
        StringBuilder stringBuilder = new StringBuilder();
        for (String word : words) {
            stringBuilder.append(word.substring(0, 1).toUpperCase()).append(word.substring(1));
        }
        return stringBuilder.toString();
    }

    private String toSingular(String word) {
        if (!StringUtils.hasText(word)) {
            return word;
        }

        if (word.matches(".*[^aeiou]ies$")) {
            return word.replaceAll("ies$", "y");
        } else if (word.matches(".*[lf]ves$")) {
            return word.replaceAll("ves$", "f");
        } else if (word.matches(".*(ch|sh|x|s|z)es$")) {
            return word.replaceAll("es$", "");
        } else if (word.matches(".*[a-z]s$") && !word.endsWith("ss")) {
            return word.replaceAll("s$", "");
        } else {
            return word;
        }
    }

    /**
     * 转驼峰
     */
    static class CamelTemplateMethodEx implements TemplateMethodModelEx {

        @Override
        public Object exec(List arguments) {
            String name = arguments.getFirst().toString();
            if (!StringUtils.hasText(name)) {
                return name;
            }

            String[] words = name.split("_");
            // 最后一个单词复数转单数
            StringBuilder stringBuilder = new StringBuilder();
            for (String word : words) {
                stringBuilder.append(word.substring(0, 1).toUpperCase()).append(word.substring(1));
            }
            return stringBuilder.toString();
        }
    }

    /**
     * 转单数
     */
    class SingularTemplateMethodEx implements TemplateMethodModelEx {

        @Override
        public Object exec(List arguments) {
            return toSingular(arguments.getFirst().toString());
        }
    }

    /**
     * 转驼峰，并将最后一个转单数
     */
    class CamelAndSingularTemplateMethodEx implements TemplateMethodModelEx {

        @Override
        public Object exec(List arguments) {
            return camelAndSingular(arguments.getFirst().toString());
        }
    }

}
